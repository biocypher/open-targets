# from abc import ABC, abstractmethod
# from collections.abc import Callable, Iterable, Sequence
# from dataclasses import dataclass
# from typing import Generic, TypeVar

# from open_targets.adapter.context import Context
# from open_targets.adapter.data_wrapper import DataWrapper
# from open_targets.adapter.output import EdgeInfo, NodeInfo
# from open_targets.data.schema import Field
# from open_targets.data.schema_base import Dataset

# TGraphComponent = TypeVar("TGraphComponent", NodeInfo, EdgeInfo)


# class DirectAccessGraphComponentGenerationDefinition(Generic[TGraphComponent], ABC):
#     @abstractmethod
#     def generate(self, context: Context) -> Iterable[TGraphComponent]:
#         """Generate graph components by directly accessing the context."""


# class DatasetRecordsGraphComponentGenerationDefinition(
#     DirectAccessGraphComponentGenerationDefinition[TGraphComponent],
#     Generic[TGraphComponent],
#     ABC,
# ):
#     @property
#     @abstractmethod
#     def requested_dataset(self) -> type[Dataset]:
#         """Dataset that is used to generate the nodes."""

#     @property
#     @abstractmethod
#     def requested_fields(self) -> Iterable[type[Field]]:
#         """Fields that are requested by this definition.

#         The overriding value will be used to calculate the datasets required by
#         the adapter in the preparation stage. A dataset field must be included
#         here for it to be provided.
#         """

#     @abstractmethod
#     def generate_from_records(
#         self,
#         context: Context,
#         records: Iterable[DataWrapper],
#     ) -> Iterable[TGraphComponent]:
#         pass

#     def generate(self, context: Context) -> Iterable[TGraphComponent]:
#         records_stream = context.get_record_stream(self.requested_dataset)
#         return self.generate_from_records(context, records_stream)


# @dataclass(frozen=True)
# class FlattenedRecordsNodeGenerationDefinition:
#     """Definition of a set of nodes to be generated."""

#     primary_id: type[Field] | ValueResolver
#     properties: list[type[Field] | PropertyResolver]


# @dataclass(frozen=True)
# class SimpleMapGraphComponentGenerationDefinition(
#     DatasetRecordsGraphComponentGenerationDefinition[TGraphComponent],
#     Generic[TGraphComponent],
#     ABC,
# ):
#     """Definition of a set of nodes to be generated."""

#     @property
#     @abstractmethod
#     def _all_fields(self) -> list[type[Field]]:
#         """All fields that are requested by this definition."""

#     @property
#     def requested_dataset(self) -> type[Dataset]:
#         return self._all_fields[0].dataset

#     @property
#     def requested_fields(self) -> Iterable[type[Field]]:
#         return self._all_fields

#     def _create_value_getter(
#         self,
#         source: str | type[Field],
#     ) -> Callable[[DataWrapper], str]:
#         if isinstance(source, str):
#             return lambda _: source
#         if isinstance(source, type):
#             return lambda record: str(record[source])
#         msg = f"Unsupported source type: {type(source)}"
#         raise ValueError(msg)

#     def _create_key_value_getter(
#         self,
#         source: type[Field] | tuple[str | type[Field], str | type[Field]],
#     ) -> Callable[[DataWrapper], tuple[str, str]]:
#         if isinstance(source, type):
#             value_getter = self._create_value_getter(source)
#             return lambda record: (source.name, value_getter(record))
#         if isinstance(source[0], str):
#             key_getter = self._create_value_getter(source[0])
#             value_getter = self._create_value_getter(source[1])
#             return lambda record: (key_getter(record), value_getter(record))
#         msg = f"Unsupported source type: {type(source)}"
#         raise ValueError(msg)


# @dataclass(frozen=True)
# class SimpleMapNodeGenerationDefinition(SimpleMapGraphComponentGenerationDefinition[NodeInfo]):
#     """Definition of a set of nodes to be generated."""

#     primary_id: type[Field]
#     labels: Sequence[str | type[Field]]
#     properties: Sequence[type[Field] | tuple[str, str | type[Field]]]

#     @property
#     def _all_fields(self) -> list[type[Field]]:
#         fields = [self.primary_id]
#         fields.extend(label for label in self.labels if isinstance(label, type))
#         for prop in self.properties:
#             if isinstance(prop, type):
#                 fields.append(prop)
#             elif isinstance(prop[1], type):
#                 fields.append(prop[1])
#         return fields

#     def generate_from_records(self, context: Context, records: Iterable[DataWrapper]) -> Iterable[NodeInfo]:
#         id_getter = self._create_value_getter(self.primary_id)
#         label_getters = [self._create_value_getter(label) for label in self.labels]
#         property_getters = [self._create_key_value_getter(prop) for prop in self.properties]

#         for record in records:
#             yield NodeInfo(
#                 id=id_getter(record),
#                 labels=[label_getter(record) for label_getter in label_getters],
#                 properties=[property_getter(record) for property_getter in property_getters],
#             )


# @dataclass(frozen=True)
# class SimpleMapEdgeGenerationDefinition(SimpleMapGraphComponentGenerationDefinition[EdgeInfo]):
#     """Definition of a set of edges to be generated."""

#     primary_id: type[Field]
#     source: type[Field]
#     target: type[Field]
#     labels: Sequence[str | type[Field]]
#     properties: Sequence[type[Field] | tuple[str, str | type[Field]]]

#     @property
#     def _all_fields(self) -> list[type[Field]]:
#         fields = [self.primary_id, self.source, self.target]
#         fields.extend(label for label in self.labels if isinstance(label, type))
#         for prop in self.properties:
#             if isinstance(prop, type):
#                 fields.append(prop)
#             elif isinstance(prop[1], type):
#                 fields.append(prop[1])
#         return fields

#     def generate_from_records(self, context: Context, records: Iterable[DataWrapper]) -> Iterable[EdgeInfo]:
#         id_getter = self._create_value_getter(self.primary_id)
#         source_getter = self._create_value_getter(self.source)
#         target_getter = self._create_value_getter(self.target)
#         label_getters = [self._create_value_getter(label) for label in self.labels]
#         property_getters = [self._create_key_value_getter(prop) for prop in self.properties]

#         for record in records:
#             yield EdgeInfo(
#                 id=id_getter(record),
#                 source_id=source_getter(record),
#                 target_id=target_getter(record),
#                 labels=[label_getter(record) for label_getter in label_getters],
#                 properties=[property_getter(record) for property_getter in property_getters],
#             )
